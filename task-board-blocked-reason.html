<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Task Board</title>

<link type="text/css" rel="stylesheet"
      href="__SERVER_URL__/js-lib/yui/2.6.0/build/reset-fonts-grids/reset-fonts-grids.css"/>
<link type="text/css" rel="stylesheet" href="__SERVER_URL__/css/toolkit/0.02/renderer.css"/>
<link type="text/css" rel="stylesheet" href="__SERVER_URL__/css/toolkit/0.02/grid.css"/>
<link type="text/css" rel="stylesheet" href="__SERVER_URL__/css/toolkit/0.02/editor.css"/>
<link type="text/css" rel="stylesheet" href="__SERVER_URL__/css/toolkit/0.02/toolkit.css"/>

<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/yui.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/toolkit.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/date.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/modal.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02.1/html.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/connection.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/grid.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02.1/renderer/renderer.js"></script>
<script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/editor.js"></script>
<!-- <script type="text/javascript" src="__SERVER_URL__/js/toolkit/0.02/datasource.js"></script> -->
<script type="text/javascript" src="/slm/js-lib/async/async.min.js"></script>
<script type="text/javascript">


(function(){

    RALLY.toolkit = RALLY.toolkit || {};

    var Lang = YAHOO.lang;

    RALLY.toolkit.DataSource = function(config, serverURL) {
        this.config         = config;
        RALLY.toolkit.applyConfigs(config, {serverURL: serverURL});
        this.serverURL      = serverURL;
        this.connection     = new RALLY.toolkit.Connection(config);
    };

    RALLY.toolkit.DataSource.NO_REF_FOUND_ERROR = 'Item does not have a _ref property';
    RALLY.toolkit.DataSource.NO_TYPE_FOUND_ERROR = 'Item does not have a _type property';

    RALLY.toolkit.DataSource.prototype = {

        get: function(callback, params) {
            this.connection.get(this.readUrl, params || {}, callback);
        },

        update: function(item, changes, callback) {
            if (!item._ref) {
                throw new Error(RALLY.toolkit.DataSource.NO_REF_FOUND_ERROR);
            }
            if (!item._type) {
                throw new Error(RALLY.toolkit.DataSource.NO_TYPE_FOUND_ERROR);
            }

            var params = {};
            params['artifact'] = {};
            params['artifact'][item._type] = changes;

            this.connection.get(item._ref, params, callback, false, 'POST');
        },

        remove: function(item, callback) {
            this.connection.get(item._ref, {}, callback, false, 'DELETE');
        }

    };

    RALLY.toolkit.TaskboardDataSource = function(config, serverURL) {
        var query = (config && config.adHocQuery) ? config : { adHocQuery: config };

        RALLY.toolkit.TaskboardDataSource.superclass.constructor.call(this, query, serverURL);
        this.readUrl = '/webservice/1.43/adhoc.js';
        this.updateUrl = '/webservice/1.43/adhoc.js';
        this.removedUrl = '/webservice/1.43/adhoc.js';
    };

    YAHOO.lang.extend(RALLY.toolkit.TaskboardDataSource, RALLY.toolkit.DataSource, {

        // look for adhoc placeholders and resolve them
        _resolvePlaceholders : function(url, model) {
            var placeholder,
                    placeholderValue,
                    placeholders = url.match(/\$\{([^\}]+)\}/g);

            if (placeholders) {
                for (var i = 0, j = placeholders.length; i < j; i++) {

                    placeholderValue = null;
                    placeholder = placeholders[i].match(/\${([^}]+)}/)[1];
                    if (model[placeholder]) {
                        if (typeof model[placeholder] === 'string') {
                            placeholderValue = model[placeholder];
                        }
                        else if (typeof model[placeholder].Results === 'object' && model[placeholder].Results.length > 0) {
                            placeholderValue = model[placeholder].Results[0]._ref;
                        }
                        else if (typeof model[placeholder]._ref === 'string') {
                                placeholderValue = model[placeholder]._ref;
                            }
                    }

                    if (placeholderValue) {
                        url = url.replace(RegExp('\\${' + placeholder + '}', 'g'), placeholderValue);
                    }
                }
            }

            return url;
        },

        getInternal: function(query, callback) {
            var that = this;

            var internalCallback = function(model) {
                var followUpQuery = { 'adHocQuery' : { } };

                var key, item, index, count, url, needSecondRequest = false;
                for (key in model) {
                    item = model[key];

                    if (item && item.TotalResultCount && item.TotalResultCount > item.PageSize) {
                        needSecondRequest = true;

                        index = item.PageSize;
                        count = 0;
                        while (index <= item.TotalResultCount) {
                            url = that._resolvePlaceholders(query.adHocQuery[key], model);
                            followUpQuery.adHocQuery[key + '' + count++] = url + '&start=' + (index+1) + ((url.indexOf('pagesize') == -1) ? '&pagesize=100' : '');
                            index += 100;
                        }
                    }
                }

                if (needSecondRequest) {

                    var finalCallback = function(secondModel) {

                        var key, item, queryKey;
                        for (key in secondModel) {
                            item = secondModel[key];

                            if (item && item.Results) {
                                queryKey = (key.match(/([^0-9]*).*/))[1];
                                //numItems = ((item.StartIndex + item.PageSize) > item.TotalResultCount) ? item.TotalResultCount - item.StartIndex + 1 : item.PageSize;

                                model[queryKey].Results = model[queryKey].Results.concat(item.Results);
                            }
                        }

                        callback(model);
                    };

                    RALLY.toolkit.TaskboardDataSource.superclass.get.call(that, finalCallback, followUpQuery);
                } else {

                    callback(model);
                }
            };

            RALLY.toolkit.TaskboardDataSource.superclass.get.call(this, internalCallback, query);
        },

        get: function(callback, query) {
            var params = this.config, that = this;

            if (Lang.isObject(query)) {
                params = query && query.adHocQuery ? query : { adHocQuery: query };
            }

            var wrappedCallback = function(model) {

                // save the model into the instance
                that.model = model;
                model = that.stitch(model);
                callback(model);
            };

            this.getInternal(params, wrappedCallback);
        },

        refreshWorkProduct: function(workProd, callback) {
            var that = this,
                params = {},
                url = workProd._ref + '?fetch=' + this.getFetchParamsFromInitialQuery('/hierarchicalrequirement');

            var wrappedCallback = function(model) {

                if (callback) {

                    var refreshedWorkProd = model.HierarchicalRequirement;
                    var listOfOwners = that.getResultsListFromModel('users');
                    if (refreshedWorkProd && refreshedWorkProd.Owner) {
                        var newOwner = that.findOwner(refreshedWorkProd.Owner, listOfOwners);
                        if (newOwner) {
                            refreshedWorkProd.Owner = newOwner;
                        }
                    }

                    callback(refreshedWorkProd);
                }
            };

            this.connection.get(url, params, wrappedCallback, false, 'GET');
        },

        refreshTask: function(task, callback) {
            var that = this, params, parentQuery = '/' + task.WorkProduct._type.toLowerCase();

            params = {
                "adHocQuery": {
                    "tasks" : "/tasks?query=(ObjectID = " + task.ObjectID + ")&fetch=" + this.getFetchParamsFromInitialQuery('/task'),
                    "parent" : parentQuery + "?query=(ObjectID = " + task.WorkProduct.ObjectID + ")&fetch=" + this.getFetchParamsFromInitialQuery(parentQuery)
                }
            };

            var wrappedCallback = function(model) {
                var key, i;

                if (callback) {

                    var listOfOwners = that.getResultsListFromModel('users');
                    for (key in model) {

                        for (i = 0; i < model[key].Results.length; i++) {

                            // need to stitch owner information back into the Owner attribute
                            if (model[key].Results[i].Owner) {

                                var newOwner = that.findOwner(model[key].Results[i].Owner, listOfOwners);
                                if (newOwner) {
                                    model[key].Results[i].Owner = newOwner;
                                }
                            }
                        }
                    }

                    // now let's massage it into the proper form

                    var newModel = that.getModelSkeleton();

                    newModel.items[0].workProducts          = model.parent.Results;
                    newModel.items[0].tasks                 = model.tasks.Results;
                    newModel.items[0].tasks[0].WorkProduct  = model.parent.Results[0];
                    newModel.items[0].workProducts[0].Task  = model.tasks.Results[0];
                    callback(newModel);
                }
            };

            this.connection.get(this.readUrl, params, wrappedCallback);
        },

        getModelSkeleton: function() {
            return {
                errors: [],
                warnings: [],
                items: [
                    {
                        workProducts: [],
                        tasks: [],
                        workspace: {
                            users: [],
                            taskUnitName: ''
                        },
                        project: { },
                        iteration: { },
                        iterations: []
                    }
                ],
                schema: {
                    Task: {
                        State: {
                            options: [
                                { Label: 'Defined',     Value: 'Defined',       ShortLabel: 'D' },
                                { Label: 'In-Progress', Value: 'In-Progress',   ShortLabel: 'P' },
                                { Label: 'Completed',   Value : 'Completed',    ShortLabel: 'C' }
                            ]
                        },
                        Owner: { options: [] },
                        Estimate: {
                            DisplayName:    'Estimate',
                            ShortName:      'Est',
                            UnitName:       '',
                            DataType:       'NUMBER'
                        },
                        ToDo: {
                            DisplayName:    'Remaining',
                            ShortName:      'To Do',
                            UnitName:       '',
                            DataType:       'NUMBER'
                        },
                        Actuals: {
                            DisplayName:    'Actual',
                            ShortName:      'Act',
                            UnitName:       '',
                            DataType:       'NUMBER'
                        }
                    },
                    WorkProduct: {
                        State: { options: [ ] },
                        Owner: { options: [] },
                        TaskEstimateTotal:  { DisplayName: 'Est' },
                        TaskRemainingTotal: { DisplayName: 'To Do' },
                        TaskActualTotal:    { DisplayName: 'Actual' }
                    }
                }
            };
        },

        /**
         * Given the prefix of an adhoc query parameter url, lookup the
         * fetch parameters in the query used when this datasource was created.
         */
        getFetchParamsFromInitialQuery: function(type) {
            var defaultFetch = 'true';

            if ( !(this.config && this.config.adHocQuery) ) {
                return defaultFetch;
            }

            var matches,
                query = this.config.adHocQuery,
                regexp = /.*fetch=([a-zA-Z,]*)/;

            for (var key in query) {

                if (query[key].indexOf(type) != -1) {

                    matches = regexp.exec(query[key]);
                    if (matches && matches.length == 2) {
                        return matches[1];
                    }
                }
            }

            // otherwise, we'll return true to fetch the whole object
            return defaultFetch;
        },

        getResultsListFromModel: function(name, model) {
            model = model || this.model;

            if (model && model[name] && model[name].Results) {
                return model[name].Results;
            }
            return [];
        },

        findOwner: function(email, listOfUsers) {

            if (typeof email === 'undefined' || !email) {
                return null;
            }

            var i, user;
            for (i = 0; i < listOfUsers.length; i++) {

                user = listOfUsers[i];
                if (user && user.LoginName && user.LoginName == email) {
                    return user;
                } else if (user && user.LoginName && user.LoginName == email) {
                    return user;
                }
            }

            return null;
        },

        findTask: function(ref) {
            var i, len, tasks = this.getResultsListFromModel('tasks');

            for (i = 0, len = tasks.length; i < len; i++) {
                if (tasks[i]._ref == ref) {
                    return tasks[i];
                }
            }
            return null;
        },

        findWorkProduct: function(ref, useCombinedWorkProducs) {
            var i, items,
                workProducts = ['stories', 'defects', 'defecsuites', 'testsets'];

            if (useCombinedWorkProducs) {
                items = this.model.workProducts;
            } else {
                items = [];
                for (i = 0; i < workProducts.length; i++) {
                    items = items.concat(this.getResultsListFromModel(workProducts[i]));
                }
            }

            for (i = 0; i < items.length; i++) {
                if (items[i]._ref && items[i]._ref == ref) {
                    return items[i];
                }
            }

            return null;
        },

        stitch: function(model) {

            // we want to end up with this:
            var newModel = this.getModelSkeleton();

            model = this.stitchTasksIntoWorkProducts(model);
            model = this.stitchUsersIntoModel(model);
            model = this.combineWorkProducts(model);
            model = this.stitchWorkProductsIntoTasks(model);

            // schema information
            // users should be sorted by _refObjectName
            var users = this.getResultsListFromModel('users', model);
            var userNames = [], userCache = {};
            for (i = 0; i < users.length; i++) {
                userNames.push(users[i]._refObjectName);
                userCache[users[i]._refObjectName] = users[i];
            }
            var userSortFunction = function(a,b) { return (a.toLowerCase() < b.toLowerCase()) ? -1: 1; };
            userNames.sort(userSortFunction);
            for (i = 0; i < userNames.length; i++) {
                newModel.schema.WorkProduct.Owner.options.push({
                    'Label': userCache[userNames[i]]._refObjectName,
                    'Value': userCache[userNames[i]].LoginName
                });
                newModel.schema.Task.Owner.options.push({
                    'Label': userCache[userNames[i]]._refObjectName,
                    'Value': userCache[userNames[i]].LoginName
                });
            }
            newModel.items[0].workspace.taskUnitName = model.taskUnit;
            newModel.schema.Task.Estimate.UnitName = model.taskUnit;
            newModel.schema.Task.ToDo.UnitName = model.taskUnit;
            newModel.schema.Task.Actuals.UnitName = model.taskUnit;

            var state;
            for (i = 0; i < model.storyStates.length; i++) {
                state = model.storyStates[i];
                newModel.schema.WorkProduct.State.options.push({
                    'Label': state, 'Value': state, 'ShortLabel': (state.indexOf('-') == -1 ? state.substr(0,1) : state.substr(state.indexOf('-')+1,1)).toUpperCase()
                });
            }

            // now let's massage it into the proper form
            newModel.items[0].workProducts = model.workProducts;
            newModel.items[0].tasks = this.getResultsListFromModel('tasks', model);
            newModel.items[0].workspace.users = users;
            newModel.items[0].iteration = this.getResultsListFromModel('iteration', model).length === 0 ? model.iteration : this.getResultsListFromModel('iteration', model)[0];
            newModel.items[0].iterations = this.getResultsListFromModel('iterations', model).reverse();
            newModel.items[0].project = model.currentProject;

            return newModel;
        },

        /**
         * This is an in-place sort, using the sortKey to index into the object for a rank value
         */
        sortList: function(array, sortKey) {
            var i, j, tmp;
            for (i = 0; i < (array.length - 1); i++) {
                for (j = i+1; j < array.length; j++) {
                    if (array[j][sortKey] < array[i][sortKey]) {
                        tmp = array[i];
                        array[i] = array[j];
                        array[j] = tmp;
                    }
                }
            }
            return array;
        },

        /**
         * This will combine all work products at the top level of the given model into
         * a single list of work products, stored at model.workProducts, ordered by Rank.
         */
        combineWorkProducts: function(model) {
            var i, wp, items,
                list = [],
                workProducts = ['stories', 'defects', 'defectsuite', 'testsets'];

            if (model.workProducts) {
                return model;
            }

            // We need to sort by Rank, but it might not be an int.
            // So let's get all the work products, build up a list of
            // their Ranks, then use that to sort them.
            for (i = 0; i < workProducts.length; i++) {
                wp = workProducts[i];

                items = this.getResultsListFromModel(wp, model);
                if (items) {
                    list = list.concat(items);
                }
            }

            model.workProducts = this.sortList(list, 'Rank');

            return model;
        },

        /**
         * Stitch the user objects into the top-level of the model
         */
        stitchUsersIntoModel: function(model) {
            var i, j, item, items,
                topLevelItems = ['stories', 'defects', 'testsets', 'defectsuite', 'tasks'],
                listOfUsers = this.getResultsListFromModel('users', model);

            for (i = 0; i < topLevelItems.length; i++) {

                item = topLevelItems[i];
                items = this.getResultsListFromModel(item, model);
                if (items) {

                    for (j = 0; j < items.length; j++) {

                        if (items[j].Owner && Lang.isString(items[j].Owner)) {

                            owner = this.findOwner(items[j].Owner, listOfUsers);
                            if (owner) {
                                items[j].Owner = owner;
                            }
                        }
                    }
                }

            }

            return model;
        },

        stitchWorkProductsIntoTasks: function(model) {
            var i, task, workProd, ref, tasks = this.getResultsListFromModel('tasks', model);

            for (i = 0; i < tasks.length; i++) {
                task = tasks[i];
                ref = task.WorkProduct && task.WorkProduct._ref ? task.WorkProduct._ref : null;

                if (ref) {
                    workProd = this.findWorkProduct(ref, true);
                    if (workProd) {
                        task.WorkProduct = workProd;
                    }
                }
            }

            return model;
        },

        stitchTasksIntoWorkProducts: function(model) {
            var i, j, k, item, items, tasks, task, ref,
                itemsToStitch = [ 'stories', 'defects' ];

            for (i = 0; i < itemsToStitch.length; i++) {

                item = itemsToStitch[i];
                if (model[item]) {

                    items = this.getResultsListFromModel(item, model);
                    for (j = 0; j < items.length; j++) {

                        tasks = items[j].Tasks;
                        if (tasks) {

                            for (k = 0; k < tasks.length; k++) {
                                ref = tasks[k]._ref;

                                task = this.findTask(ref);
                                if (task) {
                                    tasks[k] = task;
                                }
                            }
                        }
                    }
                }
            }

            return model;
        }
    });

})();


function initTaskboard() {

    //  https://rally1.rallydev.com/slm/js/toolkit/0.02/datasource.js
    // https://rally1.rallydev.com/slm/js/toolkit/0.02/grid.js
    RALLY.toolkit.TaskboardDataSource.readUrl = '/webservice/1.43/adhoc.js';
    RALLY.toolkit.TaskboardDataSource.updateUrl = '/webservice/1.43/adhoc.js';
    RALLY.toolkit.TaskboardDataSource.removedUrl = '/webservice/1.43/adhoc.js';

    // this.readUrl = '/webservice/1.17/adhoc.js';
    //     this.updateUrl = '/webservice/1.17/adhoc.js';
    //     this.removedUrl = '/webservice/1.17/adhoc.js';

    RALLY.toolkit.HTML.createMaskLayer();

    var statusDiv = null;
    var setStatus = function (msg) {
        if (!statusDiv) {
            statusDiv = Dom.get('status');
        }

        if (msg) {
            RALLY.toolkit.HTML.enableMask(null, 0);
            Dom.addClass(window.document.body, 'show-progress');
        } else {
            RALLY.toolkit.HTML.disableMask();
            Dom.removeClass(window.document.body, 'show-progress');
        }

        statusDiv.innerHTML = msg || '';
    };

    var insideRally = RALLY.toolkit.insideRally();
    var showActuals = false;
    var currentProjectOid = '__PROJECT_OID__';
    var projectScopeUp = '__PROJECT_SCOPING_UP__' == 'true';
    var projectScopeDown = '__PROJECT_SCOPING_DOWN__' == 'true';

    // use this to rebuild the full query, stitching in the
    // project scoping information from the top-level variables above
    function getQuery() {
        var scoping = "&project=${currentProject}&projectScopeUp=" + projectScopeUp + "&projectScopeDown=" + projectScopeDown;
        var paging = "&pagesize=100";

        return {
            "currentProject": "/iteration:current/project",
            "#storyType": "/typedefinition?query=(Name = \"Hierarchical Requirement\")",

            "taskUnit": "${iteration/workspace/workspaceConfiguration/taskUnitName}",
            "storyStates": "${#storyType/attributes[name=schedule state]/allowedvalues/stringvalue}",

            "iteration": "/iteration:current?fetch=name,objectid&order=StartDate",
            "iterations": "/iterations?fetch=name,objectid&order=StartDate,Name&project=${currentProject}&projectScopeUp=false&projectScopeDown=false" + paging,

            "users": "/users?fetch=displayname,loginname,emailaddress,objectid" + paging,

            "tasks": "/tasks?fetch=taskindex,name,objectid,formattedid,owner,blocked,estimate,todo,actuals,state,workproduct,blockedreason&query=(Iteration = ${iteration})" + scoping + paging,

            "stories": "/hierarchicalrequirement?fetch=rank,blocked,formattedid,name,objectid,owner,project,schedulestate,taskestimatetotal,taskremainingtotal,taskactualtotal,tasks&order=Rank&query=(Iteration = ${iteration})" + scoping + paging,
            "defects": "/defect?fetch=rank,blocked,formattedid,name,objectid,owner,project,schedulestate,taskestimatetotal,taskremainingtotal,taskactualtotal&order=Rank&query=(Iteration = ${iteration})" + scoping + paging,
            "defectsuite": "/defectsuite?fetch=rank,blocked,formattedid,name,objectid,owner,project,schedulestate,taskestimatetotal,taskremainingtotal,taskactualtotal&order=Rank&query=(Iteration = ${iteration})" + scoping + paging,
            "testsets": "/testset?fetch=rank,blocked,formattedid,name,objectid,owner,project,schedulestate,taskestimatetotal,taskremainingtotal,taskactualtotal&query=(Iteration = ${iteration})" + scoping + paging
        };
    }

    var query = getQuery();

    var renderTimeCell = function (label, value, c) {
        var v = (Lang.isValue(value)) ? value : '-';
        return '<div class="' + c + '"><div>' + label + '</div><span>' + v + '</span></div>';
    };

    var projScopeUpControl = Dom.get('proj_scope_up_control');
    var projScopeDownControl = Dom.get('proj_scope_down_control');
    if (insideRally) {
        Dom.setStyle(Dom.get('project'), 'display', 'none');
    } else {
        projScopeUpControl.checked = projectScopeUp;
        projScopeDownControl.checked = projectScopeDown;

        var updateAfterScopeChange = function (e) {
            var src = Event.getTarget(e);
            if (src.id == 'proj_scope_up_control') {
                projectScopeUp = src.checked;
            }
            else if (src.id == 'proj_scope_down_control') {
                projectScopeDown = src.checked;
            }
            query = getQuery();

            RALLY.toolkit.showMessage('Refreshing iteration with selected project scoping');
            gridController.display();
        };

        Event.addListener(projScopeUpControl, 'click', updateAfterScopeChange);
        Event.addListener(projScopeDownControl, 'click', updateAfterScopeChange);
    }

    var viewConfig = {
        columnAttribute: "State",
        columnValuesAccessor: function (model, modelSchema) {
            var stateOptions = modelSchema.Task.State.options;
            var stateNames = [];
            for (var i = 0, length = stateOptions.length; i < length; i++) {
                stateNames.push(stateOptions[i].Value);
            }
            return stateNames;
        },
        columnHeaderRenderer: function (container, value) {
            container.innerHTML = value;
        },

        // configure rows
        rowAttribute: "WorkProduct",
        rowKeyAccessor: function (workProduct) {
            return workProduct.ObjectID;
        },
        rowValuesAccessor: function (model, modelSchema) {
            return model.items[0].workProducts;
        },
        rowHeaderRenderer: function (container, value, modelSchema) {
            var state,
                    html = [],
                    schema = modelSchema.WorkProduct,
                    owner,
                    ownerClass = ['owner'],
                    divId = 'rally-workprod-' + value.ObjectID,
                    divClass = ['rally-workprod'],
                    timeClass = ['rally-time'];

            // owner could be an object literal, or a string (if the user has been deleted in the app)
            if (!value.Owner) {
                ownerClass.push('de-emphasis');
                owner = gridController.noOwnerLabel;
            } else if (Lang.isObject(value.Owner)) {
                owner = value.Owner._refObjectName;
            } else {
                ownerClass.push('de-emphasis deleted-owner');
                owner = value.Owner;
            }

            if (value.ScheduleState == 'Accepted') {
                divClass.push('rally-workprod-accepted');
                divClass.push('de-emphasis');
            } else if (value.TaskRemainingTotal == '' || value.TaskRemainingTotal == 0) {
                timeClass.push('de-emphasis');
            }

            html.push('<div class="' + divClass.join(' ') + '" id="' + divId + '">');

            state = new RALLY.toolkit.renderer.StateRenderer({
                schema: schema.State,
                state: value.ScheduleState,
                blocked: value.Blocked
            });
            html.push('<div class="state">' + state.display(false, value.ScheduleState == 'Accepted') + '</div>');

            html.push('<div class="id">' + value.FormattedID + '</div>');
            html.push('<div class="name">' + RALLY.toolkit.niceSubstring(value.Name, 100) + '</div>');
            html.push('<div class="' + ownerClass.join(' ') + '">' + owner + '</div>');

            html.push(renderTimeCell((schema.TaskEstimateTotal) ? schema.TaskEstimateTotal.DisplayName : 'Est', value.TaskEstimateTotal, timeClass.join(' ')));
            html.push(renderTimeCell((schema.TaskRemainingTotal) ? schema.TaskRemainingTotal.DisplayName : 'To Do', value.TaskRemainingTotal, timeClass.join(' ')));
            if (showActuals) {
                html.push(renderTimeCell((schema.TaskActualTotal) ? schema.TaskActualTotal.DisplayName : 'Actuals', value.TaskActualTotal, timeClass.join(' ')));
            }

            html.push('<div class="clear"></div>');
            html.push('</div>');

            container.innerHTML = html.join('');
        },

        cellSortFunction: function (a, b) {
            return a - b;
        },

        itemRankAccessor: function (item) {
            return item.TaskIndex
        },
        itemKeyAccessor: function (item) {
            return item.ObjectID
        },
        itemsAccessor: function (model) {
            return model.items[0].tasks;
        },
        itemRenderer: function (container, item, modelSchema) {

            // console.log("item",item,item.BlockedReason);

            var html = [],
                    owner,
                    taskClass = ['rally-task'],
                    ownerClass = ['owner'],
                    estClass = ['rally-time'],
                    todoClass = ['rally-time'],
                    actClass = ['rally-time'],
                    schema = modelSchema.Task,
                    contentStyle = '',
                    editIconId = 'edit-' + Dom.generateId(),
                    deleteIconId = 'delete-' + Dom.generateId();

            // owner could be an object literal, or a string (if the user has been deleted in the app)
            if (!item.Owner) {
                ownerClass.push('de-emphasis');
                owner = gridController.noOwnerLabel;
            } else if (Lang.isObject(item.Owner)) {
                owner = item.Owner._refObjectName;
            } else {
                ownerClass.push('de-emphasis deleted-owner');
                owner = item.Owner;
            }

            if (item.Blocked) {
                taskClass.push('rally-task-blocked');
            }
            if (item.State == 'Defined') {
                todoClass.push('de-emphasis');
                actClass.push('de-emphasis');
            } else if (item.State == 'Completed') {
                todoClass.push('de-emphasis');
            }

            if (item.WorkProduct && item.WorkProduct.ScheduleState == 'Accepted') {
                taskClass.push('rally-task-accepted');
                taskClass.push('de-emphasis');
            }

            html.push('<div class="' + taskClass.join(' ') + '" id="rally-task-' + item.ObjectID + '">');
            html.push('<div class="actions">');
            html.push('<img id="' + editIconId + '" src="' + RALLY.toolkit.Connection.getServerURL() + '/images/icon_pencil.gif" alt="Edit" />');
            html.push('<img id="' + deleteIconId + '" src="' + RALLY.toolkit.Connection.getServerURL() + '/images/icon_delete.gif" alt="Delete" />');
            html.push('</div>');

            if (item.Owner && Lang.isValue(item.Owner.ObjectID)) {
                // if there is an image, we need to pad the content to account for it
                contentStyle = 'margin-left: 70px';
                html.push('<div class="image">');
                html.push('<img id="edit-control" src="' + RALLY.toolkit.Connection.getServerURL() + '/profile/viewThumbnailImage.sp?tSize=60&uid=' + item.Owner.ObjectID + '" alt="" />');
                html.push('</div>');
            }

            html.push('<div style="' + contentStyle + '">');
            html.push('<div class="id">' + item.FormattedID + '</div>');
            html.push('<div class="name">' + RALLY.toolkit.niceSubstring(item.Name) + '</div>');
            html.push('<div class="' + ownerClass.join(' ') + '">' + owner + '</div>');

            html.push('<div class="time">');
            html.push(renderTimeCell((schema.Estimate) ? schema.Estimate.ShortName : 'Est', item.Estimate, estClass.join(' ')));
            html.push(renderTimeCell((schema.ToDo) ? schema.ToDo.ShortName : 'To Do', item.ToDo, todoClass.join(' ')));
            if (showActuals) {
                html.push(renderTimeCell((schema.Actuals) ? schema.Actuals.ShortName : 'Actuals', item.Actuals, actClass.join(' ')));
            }
            html.push('<div class="clear"></div>');
            html.push('</div>');
            html.push('</div>');

            if (item.Blocked) {
                html.push('<img class="blocked-icon" src="' + RALLY.toolkit.Connection.getServerURL() + '/images/icon_blocked.gif" alt="Blocked" />');
                html.push('<div class="clear"></div>');

                if (item.BlockedReason !== undefined && item.BlockedReason !== null)
                    html.push('<div class="blocked-reason">' + item.BlockedReason + "</div>");
            }

            html.push('</div>');

            container.innerHTML = html.join('');

            Event.purgeElement(editIconId);
            Event.addListener(editIconId, 'click', function (e) {
                gridController.showEditor(item, schema);
            });
            Event.purgeElement(deleteIconId);
            Event.addListener(deleteIconId, 'click', function (e) {
                gridController.deleteItem(item);
            });
        },

        // configure drag event
        dragDropCallback: function (item, value) {

            setStatus('Saving changes...');

            var cell = this.getRenderedItem(item);
            if (cell) {
                var anim = new YAHOO.util.ColorAnim(cell, { backgroundColor: { from: '#F5F4CD', to: '#fff' } });
                anim.animate();
            }
            gridController.saveChanges(item, { 'State': value }, 'taskboard', function () {
                setStatus();
            });
        }
    };

    RALLY.toolkit.Controller = function (query, viewConfig) {
        this.query = query;
        this.schemaConfig = {};
        this.viewConfig = viewConfig;
        this.dataSource = new RALLY.toolkit.TaskboardDataSource(query, '__SERVER_URL__');
        this.view = new RALLY.toolkit.Grid('taskboard', this.viewConfig);
        this.editor = new RALLY.toolkit.Editor();
    };

    RALLY.toolkit.Controller.prototype = {
        acceptedCookieKey: 'taskboard-hide-accepted',
        ownerCookieKey: 'taskboard-filter-by-owner',
        iterationCookieKey: 'taskboard-filter-by-iteration',
        projectOidCookieKey: 'taskboard-current-project',
        noOwnerLabel: 'No Owner',
        allOwnersLabel: 'All Team Members',

        getIterationByOid: function (objectID) {
            for (var i = 0; i < this.iterations.length; i++) {
                if (this.iterations[i].ObjectID == objectID) {
                    return this.iterations[i];
                }
            }

            return null;
        },

        display: function (iterationOid) {
            var len, iterations, selectedIteration,
                    html = [],
                    that = this,
                    itr = (iterationOid) ? iterationOid : RALLY.toolkit.Cookie.get(this.iterationCookieKey) || '',
                    projectOid = RALLY.toolkit.Cookie.get(this.projectOidCookieKey),
                    curProjectOid = (currentProjectOid != '') ? currentProjectOid : null;

            // if our selcted project has changed, reset the iteration ObjectID in the cookie
            if (projectOid != curProjectOid) {
                itr = '';
                RALLY.toolkit.Cookie.remove(this.iterationCookieKey);
            }
            RALLY.toolkit.Cookie.add(this.projectOidCookieKey, curProjectOid);

            // re-write the query to scope to the specified iteration
            if (itr) {
                query.iteration = "/iterations?fetch=name,objectid&order=StartDate&query=(ObjectID = " + itr + ")";
            } else {
                query.iteration = "/iteration:current?fetch=name,objectid&order=StartDate";
            }

            setStatus('Loading...');

            if (this.dataSource) {
                var queryWithParams = {
                    adHocQuery: query,
                    cpoid: currentProjectOid
                };
                // console.log("qwp",queryWithParams);
                this.dataSource.get(function (model) {
                    var i;

                    that.hideAcceptedControl = Dom.get('hide_accepted_control');
                    that.iterationSelect = Dom.get('change_iteration_control');

                    // clear out the grid container and any state-dependant vars
                    YAHOO.util.Dom.get('taskboard').innerHTML = '';
                    that.users = [];
                    YAHOO.util.Event.removeListener(that.hideAcceptedControl, 'click');
                    YAHOO.util.Event.removeListener(that.iterationSelect, 'change');


                    if (model.errors.length > 0) {
                        html.push('<ul>');
                        for (i = 0, len = model.errors.length; i < len; i++) {
                            html.push('<li>' + model.errors[i].message + '</li>');
                        }
                        html.push('</ul>');

                        RALLY.toolkit.showError(html.join(''));
                        setStatus();
                        return;
                    } else if (model.items.length == 0 || (model.items.length == 1 && model.items[0].iteration == null)) {
                        RALLY.toolkit.showError('There are no stories to display in the selected project');
                        setStatus();
                        return;
                    }

                    // add in the header info
                    Dom.get('proj_name').innerHTML = model.items[0].project.Name;
                    Dom.get('info').innerHTML = (model.items[0].iteration.Name || '') + '<br/>' + (RALLY.Date.formatNow());

                    // build the iteration select
                    selectedIteration = RALLY.toolkit.Cookie.get(that.iterationCookieKey);
                    iterations = model.items[0].iterations;
                    that.iterations = model.items[0].iterations;
                    RALLY.toolkit.HTML.clearSelect(that.iterationSelect);
                    for (i = 0, len = iterations.length; i < len; i++) {
                        that.iterationSelect.options[that.iterationSelect.options.length] = new Option(iterations[i].Name, iterations[i].ObjectID);
                        if (iterations[i].ObjectID == selectedIteration || iterations[i].Name == model.items[0].iteration.Name) {
                            RALLY.toolkit.Cookie.add(that.iterationCookieKey, iterations[i].ObjectID);
                            that.iterationSelect.selectedIndex = i;
                        }
                    }
                    Event.removeListener(that.iterationSelect, 'change');
                    Event.addListener(that.iterationSelect, 'change', that.updateIteration, that, true);

                    if (model.items[0].tasks.length == 0 && model.items[0].workProducts.length == 0) {
                        RALLY.toolkit.showError('There are no stories to display for the given iteration');
                        setStatus();
                        return;
                    }

                    // build the grid
                    that.view.display(model);

                    // should we hide accepted work?
                    if (RALLY.toolkit.Cookie.get(that.acceptedCookieKey) == 'true' || RALLY.toolkit.Cookie.get(that.acceptedCookieKey) == null) {
                        that.hideAcceptedControl.checked = true;
                        that.toggleAccepted();
                    }
                    Event.removeListener(that.hideAcceptedControl, 'click');
                    Event.addListener(that.hideAcceptedControl, 'click', that.toggleAccepted, that, true);

                    // add users into the select that were found during the rendering
                    that.refreshUserSelect();

                    setStatus();

                }, queryWithParams);
            }
        },

        showEditor: function (item, schema) {
            var editors = [];
            var teamMembers = [];
            var me = this;
            var START_OFFSET = 1;

            var tasks = [];
            tasks.push(function (callback) {
                me.getEditors(item, editors, START_OFFSET, callback);
            });

            tasks.push(function (callback) {
                me.getTeamMembers(item, teamMembers, START_OFFSET, callback);
            });

            tasks.push(function(callback) {
                me.getMe(item, callback);
            });

            async.parallel(tasks, function () {
                var sortedEditors = me.sortUsers(editors);
                var sortedTeamMembers = me.sortUsers(teamMembers);
                var currentUserOptionName = me.getOptionNameForUser(me._me);

                if (item.Owner) {
                    var itemOwnerOptionName = me.getOptionNameForUser(item.Owner);
                    if (currentUserOptionName != itemOwnerOptionName &&
                            me.indexOfOwner(sortedEditors, item.Owner) < 0 &&
                            me.indexOfOwner(sortedTeamMembers, item.Owner) < 0) {
                        sortedEditors.push({Label: itemOwnerOptionName, Value: item.Owner.LoginName});
                    }
                }

                var excludedFromEditors = me.excludeUser(sortedEditors, currentUserOptionName);
                var excludedFromTeamMembers = me.excludeUser(sortedTeamMembers, currentUserOptionName);

                var ownerOptionData = me.createOwnerOptionData(sortedEditors, sortedTeamMembers);

                var excludedUser = excludedFromEditors || excludedFromTeamMembers;
                if (excludedUser) {
                    ownerOptionData.unshift(excludedUser);
                }

                me.displayEditorForUsers(item, schema, ownerOptionData);
            });
        },

        getOptionNameForUser: function (user) {
            return user._refObjectName || user.DisplayName || user.LoginName.split('@')[0];
        },

        createOwnerOptionData: function (editors, teamMembers) {
            var ownerOptionData = [];
            var teamMemberOptGroup = {label: "Team Members:", owners: []};
            for (var i = 0; i < teamMembers.length; i++) {
                var indexOfOwner = this.indexOfOwner(editors, teamMembers[i]);
                while (indexOfOwner > -1) {
                    editors.splice(indexOfOwner, 1);
                    indexOfOwner = this.indexOfOwner(editors, teamMembers[i]);
                }

                teamMemberOptGroup.owners.push(teamMembers[i]);
            }

            if (teamMemberOptGroup.owners.length > 0) {
                ownerOptionData.push(teamMemberOptGroup);
            }

            if (editors.length > 0) {
                var editorsOptGroup = {label: "Editors:", owners: []};
                editorsOptGroup.owners = editors;
                ownerOptionData.push(editorsOptGroup);
            }

            return ownerOptionData;
        },

        indexOfOwner: function (owners, owner) {
            for (var i = 0; i < owners.length; i++) {
                if (owners[i].Value === owner.Value) {
                    return i;
                }
            }
            return -1;
        },

        displayEditorForUsers: function (item, schema, options) {
            schema.Owner.options = options;
            var editorConfig = {
                props: (showActuals) ? ['Estimate', 'ToDo', 'Actuals', 'Owner', 'State'] : ['Estimate', 'ToDo', 'Owner', 'State'],
                propertyKeyAccessors: {
                    Owner: function (prop) {
                        return prop != null ? prop.LoginName : null;
                    }
                },
                propertyValueAccessors: {
                    Owner: function (prop) {
                        return prop != null ? prop._refObjectName : null;
                    }
                },
                titleAccessor: function (obj) {
                    return obj.FormattedID + '<br/>' + obj.Name;
                },
                onErrorCallback: function () {
                    gridController.display();
                },
                onSaveCallback: function (changes) {
                    gridController.saveChanges(item, changes, 'editor');
                }
            };
            this.editor.display(item, schema, editorConfig);
        },

        excludeUser: function(usersArray, userNameToExclude) {
            for (var i = 0; i < usersArray.length; i++) {
                var user = usersArray[i];
                if (user["Label"] == userNameToExclude) {
                    var spliced = usersArray.splice(i,1);
                    return spliced[0];
                }
            }
            return null;
        },

        getEditors: function (item, options, currentOffset, callback) {
            var project = item.WorkProduct.Project;
            var baseUrl = project._ref.replace(/webservice\/\d.\d\d.*/, 'webservice/x');
            var editorUrl = baseUrl + "/project/" + project.ObjectID + "/Editors.js?fetch=DisplayName,EmailAddress,UserName&pagesize=200&start=" + currentOffset;
            YAHOO.util.Connect.asyncRequest('GET', editorUrl, {success: this.handleOwnersResponse(item, options, currentOffset, this.getEditors, callback), failure: function () {
            }, scope: this}, null);
        },

        getTeamMembers: function (item, options, currentOffset, callback) {
            var project = item.WorkProduct.Project;
            var baseUrl = project._ref.replace(/webservice\/\d.\d\d.*/, 'webservice/x');
            var editorUrl = baseUrl + "/project/" + project.ObjectID + "/TeamMembers.js?fetch=DisplayName,EmailAddress,UserName&pagesize=200&start=" + currentOffset;
            YAHOO.util.Connect.asyncRequest('GET', editorUrl, {success: this.handleOwnersResponse(item, options, currentOffset, this.getTeamMembers, callback), failure: function () {
            }, scope: this}, null);
        },

        getMe: function(item, callback) {
            var me = this;
            if(!me._me) {
                var project = item.WorkProduct.Project;
                var baseUrl = project._ref.replace(/webservice\/\d.\d\d.*/, 'webservice/x');
                var userUrl = baseUrl + '/user.js';
                YAHOO.util.Connect.asyncRequest('GET', userUrl, {
                    success: function(response) {
                        var json = JSON.parse(response.responseText);
                        me._me = json.User;
                        callback();
                    },
                    failure: function() {},
                    scope: this
                }, null);
            } else {
                callback();
            }
        },

        handleOwnersResponse: function (item, options, currentOffset, nextFunction, callback) {
            return function (response) {
                var json = JSON.parse(response.responseText);
                var results = json.QueryResult.Results;
                var pageSize = 200;
                for (i = 0; i < results.length; ++i) {
                    var label = results[i].DisplayName || results[i].UserName.split('@')[0];
                    options.push({Label: label, Value: results[i].UserName});
                }

                if (currentOffset + pageSize  <= json.QueryResult.TotalResultCount) {
                    nextFunction.call(this, item, options, currentOffset + pageSize, callback);
                } else {
                    callback();
                }
            };
        },

        sortUsers: function (options) {
            return options.sort(function (a, b) {
                if(b.owners){
                    return -1;
                }

                var aLabel = a.Label == null ? "" : a.Label.toUpperCase();
                var bLabel = b.Label == null ? "" : b.Label.toUpperCase();
                return (aLabel < bLabel) ? -1 : (aLabel > bLabel) ? 1 : 0;
            });
        },

        getParentRow: function (el) {
            while (el && el.tagName && el.tagName.toUpperCase() != 'TR') {
                el = el.parentNode;
            }
            return el;
        },

        toggleAccepted: function () {
            var i, len, row,
                    hideAcceptedControl = this.hideAcceptedControl || Dom.get('hide_accepted_control'),
                    userSelect = this.userSelect || Dom.get('filter_user_control'),
                    hideAccepted = hideAcceptedControl.checked,
                    workProds = Dom.getElementsByClassName('rally-workprod-accepted');

            RALLY.toolkit.Cookie.add(this.acceptedCookieKey, hideAccepted);

            for (i = 0, len = workProds.length; i < len; i++) {
                row = this.getParentRow(workProds[i]);

                if (hideAccepted) {
                    Dom.addClass(row, 'accepted');
                } else {
                    Dom.removeClass(row, 'accepted');
                }
            }

            if (hideAccepted && this.numItemsVisible() == 0) {
                if (userSelect.selectedIndex >= 0 && userSelect.options[userSelect.selectedIndex].value == this.allOwnersLabel) {
                    RALLY.toolkit.showWarning('The selected iteration contains only accepted stories');
                } else {
                    RALLY.toolkit.showWarning('The selected owner has only accepted stories and/or tasks');
                }
            }
        },

        refreshUserSelect: function () {
            this.userSelect = this.userSelect || Dom.get('filter_user_control');

            var selectedOwner = 0, selectedIndex = -1, options,
                    defaultUsers = [ this.allOwnersLabel, this.noOwnerLabel ],
                    users = this.getOwnersOnTaskboard();

            if (this.userSelect.selectedIndex >= 0) {
                selectedOwner = this.userSelect.options[this.userSelect.selectedIndex].value;
            } else if (RALLY.toolkit.Cookie.get(this.ownerCookieKey)) {
                selectedOwner = RALLY.toolkit.Cookie.get(this.ownerCookieKey);
            }

            // clear out current options
            RALLY.toolkit.HTML.clearSelect(this.userSelect);

            users.sort(function (a, b) {
                return (a.toLowerCase() < b.toLowerCase()) ? -1 : 1;
            });

            options = defaultUsers.concat(users);
            for (i = 0, len = options.length; i < len; i++) {
                this.userSelect.options[this.userSelect.options.length] = new Option(options[i], options[i]);
                if (selectedOwner == options[i]) {
                    selectedIndex = i;
                }
            }
            if (selectedIndex == -1) {
                // if we tried to find an owner that didn't exist, default to 'All'
                selectedIndex = 0;

                if (selectedOwner) {
                    RALLY.toolkit.showWarning('The selected owner \'' + selectedOwner + '\' does not exist in this view.  Reset the filtering to ' + this.allOwnersLabel);
                }
            }
            this.userSelect.selectedIndex = '' + selectedIndex;
            YAHOO.util.Event.removeListener(this.userSelect, 'change')
            YAHOO.util.Event.addListener(this.userSelect, 'change', this.filterByOwner, this, true);

            RALLY.toolkit.Cookie.add(this.ownerCookieKey, selectedOwner);

            this.filterByOwner();
        },

        saveChanges: function (item, changes, source, successCallback) {
            var that = this, i, len, html = [], error, isConcurrencyError;

            if (!Lang.isValue(source)) {
                source = 'taskboard';
            }

            // set to-do to 0
            if (changes.State == "Completed") {
                changes.ToDo = "0";
            }

            // always include _objectVersion
            if (!changes._objectVersion) {
                changes._objectVersion = item._objectVersion;
            }

            if (this.dataSource) {
                this.dataSource.update(item, changes, function (model) {
                    if (model.OperationResult.Errors.length == 0) {
                        that.refreshItem(item);
                        that.editor.close();
                        if (successCallback) {
                            successCallback();
                        }

                    } else {

                        html.push('<ul>');
                        for (i = 0, len = model.OperationResult.Errors.length; i < len; i++) {
                            error = model.OperationResult.Errors[i];
                            if (error.toLowerCase().indexOf('concurrency conflict') != -1 || error.toLowerCase().indexOf('could not read') != -1) {
                                isConcurrencyError = true;
                            }
                            error = that.parseSaveErrorsIntoReadableString(error);
                            if (error) {
                                html.push('<li>' + error + '</li>');
                            }
                        }
                        html.push('</ul>');

                        if (source == 'editor') {
                            that.editor.displayError(html.join(''), isConcurrencyError);
                        } else {
                            RALLY.toolkit.showWarning('The task you have drag-n-dropped has been modified by another user.<br/>Refreshing task board state.');
                            that.display();
                        }
                    }
                });
            }
        },

        parseSaveErrorsIntoReadableString: function (error) {
            var matches, tmp;

            // what type of error did we get back?
            if (error.toLowerCase().indexOf('concurrency conflict') != -1) {
                error = 'Item was modified by another user';
            } else if (error.toLowerCase().indexOf('could not read') != -1) {
                error = 'Item was deleted by another user';
            } else if (error.toLowerCase().indexOf('could not convert') != -1) {
                // let's try and strip some of the nastyness out of this message
                matches = error.match(/could not convert: (.*)/i);
                if (matches && matches.length > 1) {
                    error = matches[1];
                }
                error = error.replace('double', 'number');
            } else if (error.toLowerCase().indexOf('validation error') != -1) {
                matches = error.match(/validation error: .* ([a-z]+) >= 0 is an invalid numeric/i);
                if (matches && matches.length > 1) {
                    tmp = matches[1].toLowerCase();

                    // ignore these rollup fields
                    if (tmp == 'taskestimatetotal' || tmp == 'taskremainingtotal') {
                        return null;
                    }
                    error = '"' + tmp.substr(0, 1).toUpperCase() + tmp.substr(1) + '" must be non-negative';
                }
            }

            return error;
        },

        deleteItem: function (task) {
            var that = this;

            if (task) {
                this.dataSource.remove(task, function (model) {

                    if (model.OperationResult.Errors.length == 0) {
                        that.view.removeItem(task);

                        if (RALLY.toolkit.insideRally() && parent && parent.RALLY) {
                            parent.RALLY.util.showDeleteFlair({
                                oid: task.ObjectID,
                                record: task,
                                recordName: task.FormattedID + ': ' + task.Name,
                                restorable: true

                            });
                        }
                        that.dataSource.refreshWorkProduct(task.WorkProduct, function (newWorkProduct) {

                            that.view.refreshRowHeader(newWorkProduct);
                            that.refreshUserSelect();
                        });

                    } else {
                        RALLY.toolkit.showError('There was an error deleting the task');

                        // rebuild the task board to get back to a consistent state
                        that.updateIteration();
                    }
                });
            }
        },

        refreshItem: function (item) {
            var that = this;

            if (item) {

                this.dataSource.refreshTask(item, function (model) {
                    that.view.refreshItem(model.items[0].tasks[0]);
                    that.refreshUserSelect();
                    that.view.refreshRowHeader(model.items[0].workProducts[0]);
                });
            }

        },

        getOwnersOnTaskboard: function () {
            var i, len, div, ownerMap = {}, owners = [], items = this.view.findItems();

            for (i = 0, len = items.length; i < len; i++) {
                div = Dom.getElementsByClassName('owner', 'div', items[i])[0];
                if (div && div.innerHTML != this.noOwnerLabel && !Dom.hasClass(div, 'deleted-owner')) {
                    ownerMap[div.innerHTML] = 1;
                }
            }

            for (i in ownerMap) {
                owners.push(RALLY.toolkit.HTML.unescapeXMLEntities(i));
            }

            return owners;
        },

        numItemsVisible: function () {
            var i, len, items, num = 0;
            var comparator = function (el) {
                try {
                    return Dom.hasClass(el, 'rally-task') || Dom.hasClass(el, 'rally-workprod');
                } catch (e) {
                }
                return false;
            };

            items = this.view.findItems(comparator);
            for (i = 0, len = items.length; i < len; i++) {
                if (!(Dom.hasClass(items[i], 'hidden') || Dom.hasClass(this.getParentRow(items[i]), 'accepted') || Dom.hasClass(this.getParentRow(items[i]), 'hidden'))) {
                    num++;
                }
            }
            return num;
        },

        filterByOwner: function () {
            var i, len, that = this, shown = 0, shownAccepted = 0, itemMap = {}, rows = [], items, item,
                    sel = this.userSelect || Dom.get('filter_user_control'),
                    selected = sel.options[sel.selectedIndex];

            RALLY.toolkit.Cookie.add(this.ownerCookieKey, selected.innerHTML);

            var buildComparator = function (owner) {
                return function (item) {
                    try {
                        return owner.innerHTML == that.allOwnersLabel || YAHOO.util.Dom.getElementsByClassName('owner', 'div', item)[0].innerHTML == owner.innerHTML;
                    } catch (e) {
                    }
                    return false;
                };
            };
            var isTask = function (o) {
                return Dom.hasClass(o, 'rally-task');
            };
            var isWorkProd = function (o) {
                return Dom.hasClass(o, 'rally-workprod');
            };
            var isParentVisible = function (el) {
                for (var i = 0, len = rows.length; i < len; i++) {
                    if (rows[i] == el) {
                        return true;
                    }
                }
            };

            items = this.view.findItems(buildComparator(selected));
            for (i = 0, len = items.length; i < len; i++) {
                item = items[i];
                if (isTask(item)) {
                    itemMap[item.id] = 1;
                    rows.push(this.getParentRow(item));
                } else if (isWorkProd(item)) {
                    rows.push(this.getParentRow(item));
                }
            }

            items = this.view.findItems();
            for (i = 0, len = items.length; i < len; i++) {
                item = items[i];

                if (isTask(item)) {
                    if (typeof itemMap[item.id] == 'undefined') {
                        Dom.addClass(item, 'hidden');
                    } else {
                        if (this.hideAcceptedControl.checked && Dom.hasClass(item, 'rally-task-accepted')) {
                            shownAccepted++;
                        } else {
                            shown++;
                        }
                        Dom.removeClass(item, 'hidden');
                    }
                } else if (isWorkProd(item)) {
                    item = this.getParentRow(item);
                    if (isParentVisible(item)) {
                        if (this.hideAcceptedControl.checked && Dom.hasClass(item, 'hidden')) {
                            shownAccepted++;
                        } else {
                            shown++;
                        }
                        Dom.removeClass(item, 'hidden');
                    } else {
                        Dom.addClass(item, 'hidden');
                    }
                }
            }

            if (shown == 0 && shownAccepted > 0) {
                RALLY.toolkit.showWarning('The selected owner has only accepted stories and/or tasks');
            }
            if ((shown + shownAccepted) == 0) {
                RALLY.toolkit.showWarning('The selected owner does not own any stories or tasks');
            }
        },

        updateIteration: function () {
            var sel = this.iterationSelect,
                    selected = sel.options[sel.selectedIndex];
            RALLY.toolkit.Cookie.add(this.iterationCookieKey, selected.value);
            this.display(selected.value);
        }
    };

    var config = (query.adHocQuery) ? query : { adHocQuery: query };
    config.integrationInfo = {};
    config.integrationInfo.Name = "Mashup: Taskboard";
    config.integrationInfo.Version = "2009.5";
    config.integrationInfo.Vendor = "Rally Software";

    var gridController = new RALLY.toolkit.Controller(config, viewConfig);
    gridController.display();

}

YAHOO.util.Event.addListener(window, 'load', initTaskboard);

</script>

<style type="text/css">
        /** Customize the default grid styles **/
    body {
        font-family: tahoma, geneva, helvetica, arial, sans-serif;
    }

    .rally-grid-item {
        border: 0;
    }

    .rally-grid-item-content {
        margin: 0;
    }

    .rally-grid-column-header {
        padding: .2em;
    }

        /** Custom styles for this implementation **/
    #wrapper {
        margin: .8em;
    }

    #header {
        border-bottom: 2px solid #666;
        padding: .2em .3em;
        margin-bottom: .4em;
    }

    #header #title {
        float: left;
        text-align: left;
    }

    #header #title h3 {
        font-weight: bold;
        font-size: 1.6em;
    }

    #header #info {
        float: right;
        text-align: right;
    }

    .clear {
        clear: both;
        height: 0;
    }

    .hidden, .accepted {
        display: none;
        visibility: hidden;
        height: 0;
    }

    .de-emphasis {
        color: #999;
    }

    .rally-time {
        float: left;
        width: 58px;
        margin: .1em;
        padding: .1em;
        font-size: .8em;
        font-weight: normal;
        text-align: center;
        border: 1px solid #bbb;
    }

    .rally-time div {
        border-bottom: 1px solid #ccc;
    }

        /** work products **/
    .rally-workprod {
        margin: .5em;
        font-size: .9em;
        font-weight: normal;
    }

    .rally-workprod .id {
        clear: left;
    }

    .rally-workprod .name {
        font-size: 1.3em;
        padding-bottom: .5em;
    }

    .rally-workprod .owner {
        margin-bottom: .5em;
    }

        /** tasks **/
    .rally-task {
        padding: .8em;
        font-size: .9em;
        text-align: left;
        border: 1px solid #999;
    }

    .rally-task .name {
        font-size: 1.3em;
        margin-bottom: .5em;
    }

    .rally-task .owner {
        margin-bottom: .5em;
    }

    .rally-task .image {
        float: left;
    }

    .rally-task .actions {
        float: right;
        position: relative;
        top: -0.3em;
        right: -0.3em;
    }

    .rally-task .actions img {
        display: block;
        margin-bottom: .4em;
        cursor: pointer;
    }

    .rally-task .rally-time {
        width: 45px;
    }

    .rally-task-blocked {
        border: 1px solid #f00;
    }

    .rally-task-blocked img.blocked-icon {
        float: right;
        position: relative;
        bottom: -0.3em;
        right: -0.3em;
    }

    .blocked-reason {
        /*margin-bottom: 0.5em;*/
        text-align: center;

    }

    .rally-task-accepted {
        background-color: #ececec;
        border: 1px solid #cbcbcb;
    }

        /** filter bar **/
    #filter {
        width: 100%;
        background-color: #efefdf;
        text-align: left;
        font-size: .9em;
        padding: .2em 0;
    }

    #filter span {
        padding: 0 1em;
    }

    #filter #change_iteration, #filter #filter_user {
        border-right: 1px solid #ccc;
    }

    #filter #proj_scope_up, #filter #proj_scope_down {
        border-left: 1px solid #ccc;
    }

    #project {
        float: right;
    }

        /** status box - displays messages while loading **/
    #status {
        width: 50%;
        text-align: right;
        float: left;
        position: absolute;
        top: 0;
        left: 0;
        font-size: 11px;
        font-style: italic;
        font-weight: bold;
    }

    .show-progress {
        cursor: progress;
    }
</style>
</head>
<body>
<div id="wrapper">
    <div id="status"></div>
    <div id="header">
        <div id="title"><h3>Task Board</h3></div>
        <div id="info"></div>
        <div class="clear"></div>
    </div>
    <div id="filter">
        <div id="project">
            <span id="proj_name"></span>
                <span id="proj_scope_up">
                    Scope Up:
                    <input type="checkbox" id="proj_scope_up_control"/>
                </span>
                <span id="proj_scope_down">
                    Scope Down:
                    <input type="checkbox" id="proj_scope_down_control"/>
                </span>
        </div>
                <span id="change_iteration">
                    Change iteration:
                    <select id="change_iteration_control" size="1"></select>
                </span>
                <span id="filter_user">
                    Show work owned by:
                    <select id="filter_user_control" size="1"></select>
                </span>
                <span id="hide_accepted">
                    Hide accepted work:
                    <input type="checkbox" id="hide_accepted_control"/>
                </span>
    </div>

    <div id="taskboard"></div>
</div>
</body>
</html>